{"version":3,"sources":["src\\MathUtils.js","src\\BezierUtils.js","src\\CompiledSegment.js","src\\CompiledPath.js","index.js"],"names":["getDistance","l","r","Math","sqrt","x","y","linearEasing","start","end","position","length","getAccelerationPosition","startSpeed","acceleration","time","mPoint","multiplier","diffX","diffY","getPointOnCurve","getPointsForCurve","getPoint","MathUtils","anchor1","anchor2","control1","control2","pow","pointsOnCurve","delta","points","lastPoint","currentLength","i","point","bezierPoint","distanceInSegment","push","getPathPoint","speedTo","speedFrom","getPathPointCurved","controlBackX","controlBackY","controlFrontX","controlFrontY","isCurved","CompiledSegment","startPoint","endPoint","startLength","startDuration","duration","averageSpeed","Object","defineProperty","prototype","endSpeed","speedChange","BezierUtils","getCompiledPoint","compilePoints","curvesPrecision","compiledPoints","apply","compileCurveToPoints","precision","bezierPoints","segmentLength","speed","CompiledPath","segments","pathLength","pathDuration","segment","getPointAtTime","localTime","positionOnPoint","getPointAtDistance","localLength","createLinearPoint","createBezierPoint","compilePath","path","freeze"],"mappings":"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","file":"index.map","sourceRoot":"..","sourcesContent":["export function getDistance(l, r) {\n  return Math.sqrt(\n\t  (r.x - l.x) * (r.x - l.x) +\n\t  (r.y - l.y) * (r.y - l.y)\n  );\n}\n\nexport function linearEasing(start, end, position, length) {\n  const factor = position / length;\n  return start + (end - start) * factor;\n}\n\nexport function getAccelerationPosition(startSpeed, acceleration, time) {\n  return startSpeed * time + 0.5 * acceleration * time * time;\n}\n\nexport function mPoint(l, r, multiplier) {\n  const diffX = (r.x - l.x) * multiplier;\n  const diffY = (r.y - l.y) * multiplier;\n\n  return {\n\tx: l.x + diffX,\n\ty: l.y + diffY\n  };\n}","import * as MathUtils from './MathUtils';\n\nexport function getPointOnCurve(time, anchor1, anchor2, control1, control2) {\n  const x = Math.pow(time, 3) * (anchor2.x + 3 * (control1.x - control2.x) - anchor1.x)\n\t  + 3 * Math.pow(time, 2) * (anchor1.x - 2 * control1.x + control2.x)\n\t  + 3 * time * (control1.x - anchor1.x) + anchor1.x;\n\n  const y = Math.pow(time, 3) * (anchor2.y + 3 * (control1.y - control2.y) - anchor1.y)\n\t  + 3 * Math.pow(time, 2) * (anchor1.y - 2 * control1.y + control2.y)\n\t  + 3 * time * (control1.y - anchor1.y) + anchor1.y;\n\n\n  return { x, y };\n}\n\nexport function getPointsForCurve(pointsOnCurve, anchor1, anchor2, control1, control2){\n  const delta = 1 / (pointsOnCurve - 1);\n  const points = [];\n\n  let lastPoint ;\n  let currentLength = 0;\n\n  for (let i = 0; i < pointsOnCurve; i += 1) {\n\tconst point = getPointOnCurve(i * delta, anchor1, anchor2, control1, control2);\n    const bezierPoint = {\n      x: point.x,\n      y: point.y\n    };\n\n    if (lastPoint) {\n\t  currentLength += MathUtils.getDistance(point, lastPoint);\n\t  bezierPoint.distanceInSegment = currentLength;\n\t}\n\n\tpoints.push(bezierPoint);\n\tlastPoint = bezierPoint;\n  }\n\n  return points;\n}\n\nexport function getPoint(x, y) {\n  return { x, y };\n}\n\nexport const getPathPoint = function(x, y, speedTo, speedFrom) {\n  return getPathPointCurved(x, y, speedTo, speedFrom, x, y, x, y);\n}\n\nexport const getPathPointCurved = function(x, y, speedTo, speedFrom, controlBackX, controlBackY, controlFrontX, controlFrontY) {\n  const isCurved = (x !== controlBackX || x !== controlFrontX || y !== controlBackY || y !== controlFrontY);\n\n  return { x, y, controlBackX, controlBackY, controlFrontX, controlFrontY, speedTo, speedFrom, isCurved };\n}","import * as MathUtils from './MathUtils';\n\nexport function CompiledSegment(startPoint, endPoint, startLength, startDuration){\n  this.startPoint = startPoint;\n  this.endPoint = endPoint;\n  this.startLength = startLength;\n  this.startDuration = startDuration;\n\n  this.length = MathUtils.getDistance(startPoint, endPoint);\n  this.duration = this.length / this.averageSpeed;\n}\n\nObject.defineProperty(CompiledSegment.prototype, 'startSpeed', {\n  get: function(){\n    return this.startPoint.speedFrom;\n  }\n});\n\nObject.defineProperty(CompiledSegment.prototype, 'endSpeed', {\n  get: function(){\n    return this.endPoint.speedTo;\n  }\n});\n\nObject.defineProperty(CompiledSegment.prototype, 'speedChange', {\n  get: function(){\n    return this.endSpeed - this.startSpeed;\n  }\n});\n\nObject.defineProperty(CompiledSegment.prototype, 'averageSpeed', {\n  get: function(){\n    return (this.startSpeed + this.endSpeed) / 2;\n  }\n});\n\nObject.defineProperty(CompiledSegment.prototype, 'acceleration', {\n  get: function(){\n    return this.speedChange / this.duration;\n  }\n});","import * as BezierUtils from './BezierUtils';\nimport * as MathUtils from './MathUtils';\nimport { CompiledSegment } from './CompiledSegment';\n\nfunction getCompiledPoint(x, y, speedFrom, speedTo) {\n  return { x, y, speedFrom, speedTo };\n}\n\nfunction compilePoints(curvesPrecision, points) {\n  const compiledPoints = [];\n\n  let lastPoint;\n\n  for (let point of points) {\n\tif (lastPoint && (lastPoint.isCurved || point.isCurved)) {\n\t  compiledPoints.push.apply(compiledPoints, compileCurveToPoints(curvesPrecision, lastPoint, point));\n\t}\n\n\tcompiledPoints.push(getCompiledPoint(point.x, point.y, point.speedFrom, point.speedTo));\n\n\tlastPoint = point;\n  }\n\n  return compiledPoints;\n}\n\nfunction compileCurveToPoints(precision, startPoint, endPoint) {\n  const points = [];\n\n  const bezierPoints = BezierUtils.getPointsForCurve(\n\t  precision,\n\t  startPoint,\n\t  endPoint,\n\t  startPoint.isCurved\n\t\t  ? BezierUtils.getPoint(startPoint.controlFrontX, startPoint.controlFrontY)\n\t\t  : startPoint,\n\t  endPoint.isCurved\n\t\t  ? BezierUtils.getPoint(endPoint.controlBackX, endPoint.controlBackY)\n\t\t  : endPoint\n  );\n\n  const segmentLength = bezierPoints[bezierPoints.length - 1].distanceInSegment + MathUtils.getDistance(bezierPoints[bezierPoints.length - 1], endPoint);\n\n  for (let i = 1; i < bezierPoints.length; i++) {\n\tconst point = bezierPoints[i];\n\n\tconst speed = MathUtils.linearEasing(startPoint.speedFrom, endPoint.speedTo, point.distanceInSegment, segmentLength);\n\tpoints.push(getCompiledPoint(point.x, point.y, speed, speed));\n  }\n\n  return points;\n}\n\nexport const CompiledPath = function (curvesPrecision, points) {\n  this.points = compilePoints(curvesPrecision, points);\n  this.segments = [];\n\n  this.pathLength = 0;\n  this.pathDuration = 0;\n\n  let lastPoint = this.points[0];\n  for (let i = 1; i < this.points.length; i++) {\n\tconst point = this.points[i];\n\tconst segment = new CompiledSegment(lastPoint, point, this.pathLength, this.pathDuration);\n\n\tthis.pathLength += segment.length;\n\tthis.pathDuration += segment.duration;\n\n\tthis.segments.push(segment);\n\tlastPoint = point;\n  }\n};\n\nCompiledPath.prototype.getPointAtTime = function (time) {\n  time = time % this.pathDuration;\n\n  for (let segment of this.segments) {\n\tif (segment.startDuration + segment.duration <= time) {\n\t  continue;\n\t}\n\n\tconst localTime = time - segment.startDuration;\n\n\tconst positionOnPoint = MathUtils.getAccelerationPosition(segment.startSpeed, segment.acceleration, localTime);\n\n\treturn BezierUtils.getPoint(\n\t\tMathUtils.linearEasing(segment.startPoint.x, segment.endPoint.x, positionOnPoint, segment.length),\n\t\tMathUtils.linearEasing(segment.startPoint.y, segment.endPoint.y, positionOnPoint, segment.length)\n\t);\n  }\n\n  return BezierUtils.getPoint(0, 0);\n};\n\nCompiledPath.prototype.getPointAtDistance = function (length) {\n  length = length % this.pathLength;\n\n  for (let segment of this.segments) {\n\tif (segment.startLength + segment.length <= length) {\n\t  continue;\n\t}\n\n\tconst localLength = length - segment.startLength;\n\n\treturn BezierUtils.getPoint(\n\t\tMathUtils.linearEasing(segment.startPoint.x, segment.endPoint.x, localLength, segment.length),\n\t\tMathUtils.linearEasing(segment.startPoint.y, segment.endPoint.y, localLength, segment.length)\n\t);\n  }\n\n  return BezierUtils.getPoint(0, 0);\n};","import { getPathPoint, getPathPointCurved } from './src/BezierUtils';\nimport { CompiledPath } from './src/CompiledPath'\n\nexport const createLinearPoint = getPathPoint;\nexport const createBezierPoint = getPathPointCurved;\nexport const compilePath = function (curvesPrecision, points) {\n  var path = new CompiledPath(curvesPrecision, points);\n  Object.freeze(path);\n\n  return path;\n};\n"]}